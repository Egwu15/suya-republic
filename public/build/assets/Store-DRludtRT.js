import{R as _}from"./app-B2iKTNzp.js";const O=r=>{let o;const t=new Set,n=(i,v)=>{const g=typeof i=="function"?i(o):i;if(!Object.is(g,o)){const I=o;o=v??(typeof g!="object"||g===null)?g:Object.assign({},o,g),t.forEach(f=>f(o,I))}},s=()=>o,l={setState:n,getState:s,getInitialState:()=>d,subscribe:i=>(t.add(i),()=>t.delete(i))},d=o=r(n,s,l);return l},j=r=>r?O(r):O,C=r=>r;function G(r,o=C){const t=_.useSyncExternalStore(r.subscribe,()=>o(r.getState()),()=>o(r.getInitialState()));return _.useDebugValue(t),t}const H=r=>{const o=j(r),t=n=>G(o,n);return Object.assign(t,o),t},J=r=>r?H(r):H;function N(r,o){let t;try{t=r()}catch{return}return{getItem:s=>{var e;const u=d=>d===null?null:JSON.parse(d,void 0),l=(e=t.getItem(s))!=null?e:null;return l instanceof Promise?l.then(u):u(l)},setItem:(s,e)=>t.setItem(s,JSON.stringify(e,void 0)),removeItem:s=>t.removeItem(s)}}const p=r=>o=>{try{const t=r(o);return t instanceof Promise?t:{then(n){return p(n)(t)},catch(n){return this}}}catch(t){return{then(n){return this},catch(n){return p(n)(t)}}}},q=(r,o)=>(t,n,s)=>{let e={storage:N(()=>localStorage),partialize:a=>a,version:0,merge:(a,S)=>({...S,...a}),...o},u=!1;const l=new Set,d=new Set;let i=e.storage;if(!i)return r((...a)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),t(...a)},n,s);const v=()=>{const a=e.partialize({...n()});return i.setItem(e.name,{state:a,version:e.version})},g=s.setState;s.setState=(a,S)=>{g(a,S),v()};const I=r((...a)=>{t(...a),v()},n,s);s.getInitialState=()=>I;let f;const b=()=>{var a,S;if(!i)return;u=!1,l.forEach(c=>{var m;return c((m=n())!=null?m:I)});const h=((S=e.onRehydrateStorage)==null?void 0:S.call(e,(a=n())!=null?a:I))||void 0;return p(i.getItem.bind(i))(e.name).then(c=>{if(c)if(typeof c.version=="number"&&c.version!==e.version){if(e.migrate){const m=e.migrate(c.state,c.version);return m instanceof Promise?m.then(y=>[!0,y]):[!0,m]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,c.state];return[!1,void 0]}).then(c=>{var m;const[y,R]=c;if(f=e.merge(R,(m=n())!=null?m:I),t(f,!0),y)return v()}).then(()=>{h==null||h(f,void 0),f=n(),u=!0,d.forEach(c=>c(f))}).catch(c=>{h==null||h(void 0,c)})};return s.persist={setOptions:a=>{e={...e,...a},a.storage&&(i=a.storage)},clearStorage:()=>{i==null||i.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>b(),hasHydrated:()=>u,onHydrate:a=>(l.add(a),()=>{l.delete(a)}),onFinishHydration:a=>(d.add(a),()=>{d.delete(a)})},e.skipHydration||b(),f||I},w=q,E=J(w((r,o)=>({cartItems:[],addItem:t=>{const{cartItems:n}=o(),s=t.is_international;if(n.some(u=>u.is_international!==s)){alert("You can only select items from one category (local or international) at a time.");return}r(u=>({cartItems:[...u.cartItems,{...t,quantity:1,spice:null}]}))},removeItem:t=>{r(n=>({cartItems:n.cartItems.filter(s=>s.id!==t)}))},updateItemQuantity:(t,n)=>{r(s=>({cartItems:s.cartItems.map(e=>e.id===t?{...e,quantity:Math.max(1,e.quantity+n)}:e)}))},updateItemVariance:(t,n)=>{r(s=>({cartItems:s.cartItems.map(e=>e.id===t?{...e,spice:n}:e)}))},calculateTotal:()=>{const{cartItems:t}=o();return t.reduce((n,s)=>n+s.price*s.quantity,0)},clearCart:()=>{r({cartItems:[]})},guest:null,setGuest:t=>r({guest:t}),clearGuest:()=>r({guest:null}),saveGuestToLocalStorage:()=>{const{guest:t}=o();t&&localStorage.setItem("guestUser",JSON.stringify(t))},loadUserFromLocalStorage:()=>{const t=localStorage.getItem("savedGuest");t&&r({user:JSON.parse(t)})}})));export{E as u};
